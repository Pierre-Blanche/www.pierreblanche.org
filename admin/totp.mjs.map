{
  "version": 3,
  "sources": ["src/index.ts"],
  "sourcesContent": ["export type TOTPAlgorithm = \"SHA-1\" | \"SHA-256\" | \"SHA-384\" | \"SHA-512\"\r\nexport type TOTPEncoding = \"hex\" | \"ascii\"\r\n\r\n/**\r\n * Options for TOTP generation.\r\n * @param {number} [digits=6] - The number of digits in the OTP.\r\n * @param {TOTPAlgorithm} [algorithm=\"SHA-1\"] - Algorithm used for hashing.\r\n * @param {TOTPEncoding} [encoding=\"hex\"] - Encoding used for the OTP.\r\n * @param {number} [period=30] - The time period for OTP validity in seconds.\r\n * @param {number} [timestamp=Date.now()] - The current timestamp.\r\n */\r\ntype Options = {\r\n\tdigits?: number\r\n\talgorithm?: TOTPAlgorithm\r\n\tencoding?: TOTPEncoding\r\n\tperiod?: number\r\n\ttimestamp?: number\r\n}\r\n\r\nexport class TOTP {\r\n\t/**\r\n\t * Generates a Time-based One-Time Password (TOTP).\r\n\t * @async\r\n\t * @param {string} key - The secret key for TOTP.\r\n\t * @param {Options} options - Optional parameters for TOTP.\r\n\t * @returns {Promise<{otp: string, expires: number}>} A promise that resolves to an object containing the OTP and its expiry time.\r\n\t */\r\n\tstatic async generate(key: string, options?: Options): Promise<{ otp: string; expires: number }> {\r\n\t\tconst _options: Required<Options> = {\r\n\t\t\tdigits: 6,\r\n\t\t\talgorithm: \"SHA-1\",\r\n\t\t\tencoding: \"hex\",\r\n\t\t\tperiod: 30,\r\n\t\t\ttimestamp: Date.now(),\r\n\t\t\t...options,\r\n\t\t}\r\n\t\tconst epochSeconds = Math.floor(_options.timestamp / 1000)\r\n\t\tconst timeHex = this.dec2hex(Math.floor(epochSeconds / _options.period)).padStart(16, \"0\")\r\n\r\n\t\tconst keyBuffer = _options.encoding === \"hex\" ? this.base32ToBuffer(key) : this.asciiToBuffer(key)\r\n\r\n\t\tconst hmacKey = await this.crypto.importKey(\"raw\", keyBuffer, { name: \"HMAC\", hash: { name: _options.algorithm } }, false, [\"sign\"])\r\n\t\tconst signature = await this.crypto.sign(\"HMAC\", hmacKey, this.hex2buf(timeHex))\r\n\r\n\t\tconst signatureHex = this.buf2hex(signature)\r\n\t\tconst offset = this.hex2dec(signatureHex.slice(-1)) * 2\r\n\t\tconst masked = this.hex2dec(signatureHex.slice(offset, offset + 8)) & 0x7fffffff\r\n\t\tconst otp = masked.toString().slice(-_options.digits)\r\n\r\n\t\tconst period = _options.period * 1000\r\n\t\tconst expires = Math.ceil((_options.timestamp + 1) / period) * period\r\n\r\n\t\treturn { otp, expires }\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a hexadecimal string to a decimal number.\r\n\t * @param {string} hex - The hex string.\r\n\t * @returns {number} The decimal representation.\r\n\t */\r\n\tprivate static hex2dec(hex: string): number {\r\n\t\treturn parseInt(hex, 16)\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a decimal number to a hexadecimal string.\r\n\t * @param {number} dec - The decimal number.\r\n\t * @returns {string} The hex representation.\r\n\t */\r\n\tprivate static dec2hex(dec: number): string {\r\n\t\treturn (dec < 15.5 ? \"0\" : \"\") + Math.round(dec).toString(16)\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a base32 encoded string to an ArrayBuffer.\r\n\t * @param {string} str - The base32 encoded string to convert.\r\n\t * @returns {ArrayBuffer} The ArrayBuffer representation of the base32 encoded string.\r\n\t */\r\n\tprivate static base32ToBuffer(str: string): ArrayBuffer {\r\n\t\tstr = str.toUpperCase()\r\n\t\tlet length = str.length\r\n\t\twhile (str.charCodeAt(length - 1) === 61) length-- // Remove pads\r\n\r\n\t\tconst bufferSize = (length * 5) / 8 // Estimate buffer size\r\n\t\tconst buffer = new Uint8Array(bufferSize)\r\n\t\tlet value = 0, bits = 0, index = 0\r\n\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tconst charCode = this.base32[str.charCodeAt(i)]\r\n\t\t\tif (charCode === undefined) throw new Error(\"Invalid base32 character in key\")\r\n\t\t\tvalue = (value << 5) | charCode\r\n\t\t\tbits += 5\r\n\t\t\tif (bits >= 8) buffer[index++] = value >>> (bits -= 8)\r\n\t\t}\r\n\t\treturn buffer.buffer as ArrayBuffer\r\n\t}\r\n\r\n\t/**\r\n\t * Converts an ASCII string to an ArrayBuffer.\r\n\t * @param {string} str - The ASCII string to convert.\r\n\t * @returns {ArrayBuffer} The ArrayBuffer representation of the ASCII string.\r\n\t */\r\n\tprivate static asciiToBuffer(str: string): ArrayBuffer {\r\n\t\tconst buffer = new Uint8Array(str.length)\r\n\t\tfor (let i = 0; i < str.length; i++) {\r\n\t\t\tbuffer[i] = str.charCodeAt(i)\r\n\t\t}\r\n\t\treturn buffer.buffer as ArrayBuffer\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a hexadecimal string to an ArrayBuffer.\r\n\t * @param {string} hex - The hexadecimal string to convert.\r\n\t * @returns {ArrayBuffer} The ArrayBuffer representation of the hexadecimal string.\r\n\t */\r\n\tprivate static hex2buf(hex: string): ArrayBuffer {\r\n\t\tconst buffer = new Uint8Array(hex.length / 2)\r\n\t\tfor (let i = 0, j = 0; i < hex.length; i += 2, j++) buffer[j] = this.hex2dec(hex.slice(i, i + 2))\r\n\t\treturn buffer.buffer as ArrayBuffer\r\n\t}\r\n\r\n\t/**\r\n\t * Converts an ArrayBuffer to a hexadecimal string.\r\n\t * @param {ArrayBuffer} buffer - The ArrayBuffer to convert.\r\n\t * @returns {string} The hexadecimal string representation of the buffer.\r\n\t */\r\n\tprivate static buf2hex(buffer: ArrayBuffer): string {\r\n\t\treturn [...new Uint8Array(buffer)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\")\r\n\t}\r\n\r\n\t/**\r\n\t * The cryptographic interface used for HMAC operations.\r\n\t * Chooses the Web Crypto API if available, otherwise falls back to Node's crypto module.\r\n\t * @type {SubtleCrypto}\r\n\t */\r\n\t/* istanbul ignore next */\r\n\tprivate static readonly crypto: SubtleCrypto = globalThis.crypto.subtle\r\n\r\n\t/**\r\n\t * A precalculated mapping from base32 character codes to their corresponding index values for performance optimization.\r\n\t * This mapping is used in the base32ToBuffer method to convert base32 encoded strings to their binary representation.\r\n\t */\r\n\tprivate static readonly base32: { [key: number]: number } = {\r\n\t\t50: 26,\r\n\t\t51: 27,\r\n\t\t52: 28,\r\n\t\t53: 29,\r\n\t\t54: 30,\r\n\t\t55: 31,\r\n\t\t65: 0,\r\n\t\t66: 1,\r\n\t\t67: 2,\r\n\t\t68: 3,\r\n\t\t69: 4,\r\n\t\t70: 5,\r\n\t\t71: 6,\r\n\t\t72: 7,\r\n\t\t73: 8,\r\n\t\t74: 9,\r\n\t\t75: 10,\r\n\t\t76: 11,\r\n\t\t77: 12,\r\n\t\t78: 13,\r\n\t\t79: 14,\r\n\t\t80: 15,\r\n\t\t81: 16,\r\n\t\t82: 17,\r\n\t\t83: 18,\r\n\t\t84: 19,\r\n\t\t85: 20,\r\n\t\t86: 21,\r\n\t\t87: 22,\r\n\t\t88: 23,\r\n\t\t89: 24,\r\n\t\t90: 25,\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["TOTP", "key", "options", "_options", "epochSeconds", "timeHex", "keyBuffer", "hmacKey", "signature", "signatureHex", "offset", "otp", "period", "expires", "hex", "dec", "str", "length", "bufferSize", "buffer", "value", "bits", "index", "i", "charCode", "j", "x", "__publicField"]
}
